let RoomFactory;_3fb‍.x([["ServerRooms",()=>ServerRooms]]);_3fb‍.w("../factories/RoomFactory.js",[["RoomFactory",["RoomFactory"],function(v){RoomFactory=v}]]);

       class ServerRooms {

    constructor() {
        this.rooms = new Map();
        this.playerRooms = new Map();
        this.lastRoomID = 0;
    }

    joinRoom(roomID, userID) {
        if (this.rooms.has(roomID)) {
            this.playerRooms.set(userID, roomID);
            this.rooms.get(roomID).connect(userID);
        }
    }

    disconnect(userID) {
        let roomID = this.playerRooms.get(userID);
        if (this.rooms.has(roomID)) {
            this.rooms.get(roomID).disconnect(userID);
        }
    }

    createRoom(type) {
        this.rooms.set(++ this.lastRoomID, RoomFactory.getByType(type));
        _3fb‍.g.console.log(this.rooms);
        return this.lastRoomID;
    }

    leave(roomID) {
        this.rooms.delete(roomID);
    }

    getRoomData(userID) {
        let roomID = this.playerRooms.get(userID);
        if (this.rooms.has(roomID)) {
            let room = this.rooms.get(roomID);
            return {
                'players': room.players,
                'map': room.gameMap.map
            }
        }
    }

    getBestRoom(type) {
        let roomID,
            roomPlayers = -1;
        for (let [key, room] of this.rooms.entries()) {
            if (room.type === type && room.canBeJoined()) {
                if (room.users.size > roomPlayers) {
                    roomID = key;
                    roomPlayers = room.users.size;
                }
            }
        }
        if (roomPlayers === -1) {
            roomID = this.createRoom(type);
        }
        _3fb‍.g.console.log("returninggg  " + roomID);
        return roomID;
    }

}